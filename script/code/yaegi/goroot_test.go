package yaegi

import (
	"bytes"
	"fmt"
	"go/build"
	"strings"
	"testing"

	"github.com/stretchr/testify/require"

	"project/internal/system"
	"project/script/internal/config"
	"project/script/internal/log"
)

func init() {
	log.SetSource("yaegi")
}

func TestExportGoRoot(t *testing.T) {
	var cfg config.Config
	if !config.Load("../../../config.json", &cfg) {
		t.Fatal("failed to load project config")
	}
	for _, item := range [...]*struct {
		version int
		path    string
	}{
		{version: 16, path: cfg.Common.Go116x},
		{version: 10, path: cfg.Common.Go1108},
		{version: 11, path: cfg.Special.Go11113},
		{version: 12, path: cfg.Special.Go11217},
		{version: 13, path: cfg.Special.Go11315},
		{version: 14, path: cfg.Special.Go11415},
		{version: 15, path: cfg.Special.Go115x},
	} {
		if item.path == "" {
			continue
		}
		testExportGoRoot(t, item.version, item.path)
	}
}

func testExportGoRoot(t *testing.T, version int, path string) {
	const template = `
// Code generated by script/code/yaegi/goroot_test.go. DO NOT EDIT.

// +build go1.%d,!go1.%d

package goroot

import (
%s)

// Symbols stores the map of unsafe package symbols.
var Symbols = map[string]map[string]reflect.Value{}

func init() {
%s}

%s`
	// set go root path
	build.Default.GOROOT = path
	importBuf := bytes.NewBuffer(make([]byte, 0, 2048))
	initBuf := bytes.NewBuffer(make([]byte, 0, 4096))
	srcBuf := bytes.NewBuffer(make([]byte, 0, 128*1024))

	for _, pkg := range []string{
		"archive/zip",
		"reflect",
		"strings",
	} {
		init := strings.NewReplacer("/", "_", ".", "_", "-", "_").Replace(pkg)
		_, _ = fmt.Fprintf(importBuf, "\t\"%s\"\n", pkg)
		_, _ = fmt.Fprintf(initBuf, "\tinit_%s()\n", init)
		code, err := generateCode(pkg, init)
		require.NoError(t, err)
		srcBuf.WriteString(code)
	}

	// generate code
	src := fmt.Sprintf(template[1:], version, version+1, importBuf, initBuf, srcBuf)

	// print and save code
	fmt.Println(src)
	path = fmt.Sprintf("../../../internal/interpreter/yaegi/goroot/bundle_go1_%d.go", version)
	err := system.WriteFile(path, []byte(src))
	require.NoError(t, err)
}
